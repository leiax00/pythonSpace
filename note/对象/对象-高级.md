#### 1. 使用 `__slots__`
> 1. 在实例化一个class后,可以动态的给该实例绑定任何属性和方法;(体现动态语言的灵活性)  
绑定的方法和属性,仅对当前实例生效; 方式: `实例名.属性名/方法名`  
> 2. 给所有实例绑定方法, 需要给class绑定方法; 方式: `类名.属性名/方法名`  

`__slots__: 用于限制一个class实例能够添加的属性; 使用方式如下:`  
```python
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```
绑定不存在 `__slots__`参数中的属性,会出现 `AttributeError` 错误;   
使用 `__slots__` 要注意，`__slots__` 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的;  
除非在子类中也定义 `__slots__` ，这样，子类实例允许定义的属性就是自身的` __slots__` 加上父类的 `__slots__`。  

#### 2. 使用 `@property`  
`@property` 是用于限制及校验参数的注解, 提供类似的get and set方法的形式,示例如下:
```python
class Student(object):

    @property
    def score(self): # 该方法类似定义了属性score的getter方法;
        return self._score

    @score.setter
    def score(self, value): # 该方法类似定义了属性score的setter方法;setter方法不定义则获得一个只读属性;  
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self.score = value
# 方法的调用:
s = Student()
s.score = 99 #调用了上述的setter方法, 自动带上setter中的参数校验;
print(s.score) # 99, 调用了上述的getter方法
```

#### 3. 多重继承  
python 是可以多重继承的, 继承格式: 
```python
class Dog(Mammal, Runnable):
    pass
```
通常情况下, python的继承主线都是单一继承的, 而其余继承,通常称之为 ***`MixIn`***  
***`MixIn`*** 的命名一般为 ***`XxxMixIn`***;  
```python
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```

#### 4. 定制类
> python中class的toString方法: `__str__`;  
```python
class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self): # 注意: toString()方法
        return 'Student object (name: %s)' % self.name

print(Student('Michael')) # Student object (name: Michael)
```
以下这种方式调用的不是 `__str()__`, 而是 `__repr__`  
 `__str()__` : 返回用户看到的字符串  
 `__repr__`  : 返回程序开发者看到的字符串，也就是说，`__repr__()` 是为调试服务的
```python
s = Student('Michael')
s # 这种方式结果: <__main__.Student object at 0x109afb310>
```
> 使一个class 变得可迭代: `__iter__`  
`__iter__` 可使一个class变得同list或tuple一样, 可被 `for ... in class_A`迭代;  
for循环开始后, 会不断迭代class中的 `__next__` 方法, 直到遇到 `StopIteration` 错误时退出循环;  
```python
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
fib = Fib()
print([n for n in fib])  # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
```
> 使一个class变得同list一样可以使用下标进行元素获取 : `__getitem__`  
```python
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
fib = Fib()
print(fib[0])  # 1
print(fib[3])  # 3
```
`注意: list可以进行切片, 但上述代码会报错,原因是`__getitem__()`传入的参数可能是一个int，也可能是一个切片对象`slice`, 优化如下:  
```python
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L
fib = Fib()
print(fib[0:5])  # [1, 1, 2, 3, 5]
```