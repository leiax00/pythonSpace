# Redis锁的概念及构建
> 代码示例参见: leiax00/redis_demo/lock/distributed_lock.py
* 乐观锁<br/>
  Redis使用WATCH命令来代替对数据进行加锁，因为WATCH只会在数据被其他客户端抢先修改了的情况下通知执行了这个命令的客户端，而不会阻止其他客户端对数据进行修改，所以这个命令被称为乐观锁（optimistic
  locking）
* 分布式锁<br/>
  为了对Redis存储的数据进行排他性访问，客户端需要访问一个锁，这个锁必须定义在一个可以让所有客户端都看得见的范围之内，而这个范围就是Redis本身;<br/>
  不是给同一个进程中的多个线程使用，也不是给同一台机器上的多个进程使用，而是由不同机器上的不同Redis客户端进行获取和释放的。何时使用以及是否使用WATCH或者锁取决于给定的应用程序：有的应用不需要使用锁就可以正确地运行，而有的应用只需要使用少量的锁，还有的应用需要在每个步骤都使用锁，不一而足。
```
一些导致锁出现不正确行为的原因，以及锁在不正确运行时的症状:
    * 持有锁的进程因为操作时间过长而导致锁被自动释放，但进程本身并不知晓这一点，甚至还可能会错误地释放掉了其他进程持有的锁。
    * 一个持有锁并打算执行长时间操作的进程已经崩溃，但其他想要获取锁的进程不知道哪个进程持有着锁，也无法检测出持有锁的进程已经崩溃，只能白白地浪费时间等待锁被释放。
    * 在一个进程持有的锁过期之后，其他多个进程同时尝试去获取锁，并且都获得了锁。
    * 上面提到的第一种情况和第三种情况同时出现，导致有多个进程获得了锁，而每个进程都以为自己是唯一一个获得锁的进程。
```
## 使用Redis构建锁
1. 首先需要获取锁, 使用命令 `SETNX`, 
   这个命令只会在键不存在的情况下为键设置值，而锁要做的就是将一个随机生成的128位UUID设置为键的值，并使用这个值来防止锁被其他进程取得。
   <br/>如果程序在尝试获取锁的时候失败，那么它将不断地进行重试，直到成功地取得锁或者超过给定的时限为止.
2. 进行业务处理
3. 释放锁: 由于程序在持有锁期间,其他客户端可能会擅自相对锁进行修改,
   需确认锁中值未发生变化之后删除该键 <br/>
4. 从2.6.12版本开始，redis为`SET`命令增加了一系列选项, 可用于完全取代`SETNX`,
   `SETEX`, `PSETEX`的功能:
    ```
    SET key value [EX seconds] [PX milliseconds] [NX|XX]
        EX seconds – 设置键key的过期时间，单位时秒
        PX milliseconds – 设置键key的过期时间，单位时毫秒
        NX – 只有键key不存在的时候才会设置key的值
        XX – 只有键key存在的时候才会设置key的值
    ```
   
## 细粒度锁
> 通过自定义一个key来获取锁的方式, 可以较之watch控制到更细粒度,
> 从而减少碰撞重试次数:<br/>
> 比如对于hash来说,那么可以控制到key下面的某一个field,
> 而对于watch则只能控制到key
 
 `注: 细粒度锁会大大增加死锁发生的概率`

## 带有超时限制特性的锁
> 针对锁持有者进入异常状态,导致锁无法正常释放的情况.

## 计数信号量
> 一种锁: 可以让用户限制一项资源最多能够同时被多少个进程访问,
> 通常用于限定能够同时使用的资源数量. <br/> **代码示例:leiax00/redis_demo/lock/distribute_semaphore.py**
* 计数信号量和其他锁的区别:<br/>
  当客户端获取锁失败的时候,客户端通常会选择进行等待;
  而当客户端获取计数信号量失败的时候,客户端通常会选择立即返回失败结果.
  
***构造具有超时特性的计数信号量通常方式:*** <br/> ----1.
构造分布式锁的方式,通过`expire`命令来设置过期时间<br/> ----2. 使用有序集合,
程序将为每个尝试获取信号量的进程生成一个唯一标识符,并将这个标识符用作有序集合的成员,而成员对应的分值则是进程尝试获取信号量时的Unix时间戳;
然后通过检测自己成员的排名,
当低于可获取信号量总数的时候,表示成功获取了信号量;反之需要移除自己的标识符;

**缺陷: 由于不同客户端所在时间并不一定一致, 如A的系统时间比B的系统时间快10ms,
那么可能会导致A的信号量提前释放; 很难有一个统一的标准在不同客户端之间传递;** 

## 公平信号量
> 给信号量实现添加一个计数器以及一个有序集合.
> 其中,计数器通过持续的执行自增操作,创建出一种类似于计时器(timer)的机制,确保最先对计数器执行自增操作的客户端能够获得信号量.
> 以计数器生成的值作为分值,存储到一个信号量拥有者有序集合中;

***注:*** *公平信号量实质是,超时依然依据各客户端本地时间,
而排序则通过计数器来实现;因此同样存在各客户端时间不一致导致信号量被提前释放的情况;*

***适用范围:*** *各客户端时间间隔在一两秒之内是可以接受的*

## 刷新信号量
> 适用于流API的使用场景, 即长时间的占用; 因此需要在公平信号量的基础上,
> 通过刷新信号量,来防止其过期

## 消除竞争关系
> 以上信号量都有可能存在竞争的关系, 因此可以在外层再嵌一层分布式锁,
> 来限制其变化量, 从而消除竞争
