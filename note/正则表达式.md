[TOC]: # " AAA"
#### 概念
以一个字符串来描述一类字符串;<br/>
描述了模式的重复或者表述多个字符，按照某种模式匹配一系列有相似特征的字符串；<br/>
<b>设计思想：</b>用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的；<br/>

python术语中，两种完成模式匹配（pattern-matching）的方式：
>1. 搜索（searching）：在字符串任意部分中搜索匹配的模式，通过 `search()` 函数来实现；
>2. 匹配（matching） ：指判断一个字符串能否从起始处完全或部分的匹配某个模式，通过 `match()` 函数来实现;
<font color="red">
注: 当严格讨论与字符串中模式相关的正则表达式时, 全部使用术语 "匹配"; 至于"搜索" 和 "匹配"两种方式按照python怎么完成模式匹配来进行区分;
</font><br/>

在正则表达式中，如果直接给出字符，就是精确匹配。<br/>
按照某种模式来进行匹配的表达式, 姑且叫模式匹配.<br/>
<table>
    <tr>
        <th>正则表达式模式</th>
        <th>匹配的字符串</th>
    </tr>
    <tr>
        <td>python</td>
        <td>python</td>
    </tr>
    <tr>
        <td>[a-zA-Z0-9]*</td>
        <td>abc123</td>
    </tr>
</table>

#### 特殊符号和字符
列举常见的形成正则表达式的特殊符号和字符: 参见: `附表一: 常见正则表达式符号和特殊字符`<br/>




#### python中正则表达式的支持模块 -- `re`

#### 附表一: 常见正则表达式符号和特殊字符
<table>
    <tr>
        <th>表示法</th>
        <th>描述</th>
        <th>表达式示例</th>
    </tr>
    <tr>
        <th colspan="3">符号</th>
    </tr>
    <tr>
        <td>literal</td>
        <td>匹配文本字符串的字面值literal</td>
        <td>foo</td>
    </tr>
    <tr>
        <td>re1|re2</td>
        <td>匹配正则表达式re1或者re2</td>
        <td>foo|bar</td>
    </tr>
    <tr>
        <td>.</td>
        <td>匹配任意字符( \n除外 )</td>
        <td>b.b</td>
    </tr>
    <tr>
        <td>^</td>
        <td>匹配字符串起始部分</td>
        <td>^Dear</td>
    </tr>
    <tr>
        <td>$</td>
        <td>匹配字符串终止部分</td>
        <td>/bin/*sh$</td>
    </tr>
    <tr>
        <td>*</td>
        <td>匹配 0 次或多次前面出现的正则表达式</td>
        <td>[a-zA-Z0-9]*</td>
    </tr>
    <tr>
        <td>+</td>
        <td>匹配 1 次或多次前面出现的正则表达式</td>
        <td>[a-z]+\.com</td>
    </tr>
    <tr>
        <td>?</td>
        <td>匹配 0 次或 1 次前面出现的正则表达式</td>
        <td>goo?</td>
    </tr>
    <tr>
        <td>{N}</td>
        <td>匹配 N 次前面出现的正则表达式</td>
        <td>[0-9]{3}</td>
    </tr>
    <tr>
        <td>{M,N}</td>
        <td>匹配 M ~ N 次前面出现的正则表达式</td>
        <td>[0-9]{1,3}</td>
    </tr>
    <tr>
        <td>[...]</td>
        <td>匹配来自字符集的任意单一字符</td>
        <td>[aeiou]</td>
    </tr>
    <tr>
        <td>[..x-y..]</td>
        <td>匹配 x~y 范围内的任意单一字符</td>
        <td>[0-9], [A-Za-z]</td>
    </tr>
    <tr>
        <td>[^...]</td>
        <td>不匹配此字符集中出现的任何一个字符,包括某一范围的字符(如果在此字符集中出现)</td>
        <td>[^aeiou], [^A-Za-z0-9]</td>
    </tr>
    <tr>
        <td>(*|+|?|{})?</td>
        <td>用于匹配上面频繁出现/重复出现符号的非贪婪版本</td>
        <td>.*?[a-z]</td>
    </tr>
    <tr>
        <td>(...)</td>
        <td>匹配封闭的正则表达式,然后另存为子组</td>
        <td>([0-9]{3})?, f(oo|u)bar</td>
    </tr>
    <tr>
        <th colspan="3">特殊字符</th>
    </tr>
    <tr>
        <td>\d</td>
        <td>匹配任何十进制数字, 与[0-9]一致 ( \D 与 \d 相反, 不匹配任何非数值型的数字)</td>
        <td>data\d+.txt</td>
    </tr>
    <tr>
        <td>\w</td>
        <td>匹配任何字母数字字符, 与[A-Za-z0-9]相同 ( \W 与之相反 )</td>
        <td>[A-Za-z_]\w+</td>
    </tr>
    <tr>
        <td>\s</td>
        <td>匹配任何空格字符, 与[\n\t\r\v\f]相同 ( \S 与之相反 )</td>
        <td>of\sthe</td>
    </tr>
    <tr>
        <td>\b</td>
        <td>匹配任何单词边界 (\B与之相反 )</td>
        <td>\bThe\b</td>
    </tr>
    <tr>
        <td>\N</td>
        <td>匹配以保存的子组N ( 参见上面的 (...) )</td>
        <td>price:\16</td>
    </tr>
    <tr>
        <td>\c</td>
        <td>逐字匹配任何特殊字符c (即仅按照字面意义匹配,不匹配特殊含义)</td>
        <td>\. , \\ , \* </td>
    </tr>
    <tr>
        <td>\A(\Z)</td>
        <td>匹配字符串的起始(结束) (另见上面的 ^ 和 $ )</td>
        <td>\ADear</td>
    </tr>
    <tr>
        <th colspan="3">扩展表示法</th>
    </tr>
    <tr>
        <td>(?iLmsux)</td>
        <td>在正则表达式中嵌入一个或者多个特殊 "标记" 参数( 或者通过函数/方法 )</td>
        <td>(?x), (? im)</td>
    </tr>
    <tr>
        <td>(?...)</td>
        <td>表示一个匹配不用保存的分组</td>
        <td>(?:\w+\.)*</td>
    </tr>
    <tr>
        <td>(?P<name>...)</td>
        <td>像一个仅由 name 标识而不是数字 ID 标识的正则分组匹配</td>
        <td>(?P<data>)</td>
    </tr>
    <tr>
        <td>(?P=name)</td>
        <td>在同一个字符串中匹配由(?P<name>)分组的之前文本</td>
        <td>(?P=data)</td>
    </tr>
    <tr>
        <td>(?#...)</td>
        <td>表示注释, 所有内容都被忽略</td>
        <td>(?#comment)</td>
    </tr>
    <tr>
        <td>(?=...)</td>
        <td>匹配条件是如果...出现在之后的位置,而不适用输入字符串;称作正向前视断言</td>
        <td>(?=.com)</td>
    </tr>
    <tr>
        <td>(?!...)</td>
        <td>匹配条件是如果...不出现在之后的位置.而不适用输入字符串;称作负向前视断言</td>
        <td>(?!.net)</td>
    </tr>
    <tr>
        <td>(?<=...)</td>
        <td>匹配条件是如果...出现在之前的位置.而不适用输入字符串;称作正向后视断言</td>
        <td>(?<=800-)</td>
    </tr>
    <tr>
        <td>(?<!...)</td>
        <td>匹配条件是如果...不出现在之前的位置.而不适用输入字符串;称作负向后视断言</td>
        <td>(?<!192\.168\.)</td>
    </tr>
    <tr>
        <td>(?(id/name)Y|N))</td>
        <td>如果分组所提供的 id 或者 name(名称) 存在, 就返回正则表达式的条件匹配Y, 如果不存在,就返回N; |N 是可选项</td>
        <td>(?(1)y|x)</td>
    </tr>
</table>